<HTML><BODY>

<CENTER><H3>Интерфейс с графическими устройствами</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspМногим типам приложений Windows для организации полного
интерфейса пользователя нужны только окна, блоки диалога и
управляющие элементы.  Но некоторым приложениям  (например,  программами
рисования и манипулирования изображениями) требуется наличие
графических средств для заполнения окон.  Эта графика может  быть  в
форме линий, форм, текста и побитовых образов.

<P>&nbsp&nbsp&nbsp&nbspДля предоставления  приложениям  графических  функциональных
возможностей Windows имеет набор функций,  называемый интерфейсом
с  графическим устройством - GDI.  GDI можно представить себе как
графическую машину,  которую используют  приложения  Windows  для
отображения и манипулирования графикой. Функции GDI предоставляют
вашему приложению возможности рисования,  которые не  зависят  от
используемого дисплея. Например, вы можете использовать одни и те
же функции для организации вывода на дисплей EGA,  на дисплей VGA
и даже на принтер PostScript.

<P>&nbsp&nbsp&nbsp&nbspАппаратная независимость   реализуется  через  использование
драйверов устройств,  которые переводят функции  GDI  в  команды,
воспринимаемые используемым устройством вывода. Это означает, что
вам не нужно беспокоиться о том,  как конкретное устройство
работает с  графическим  образом.  Вы  сообщаете драйверу,  что нужно
что-то сделать, и он работает с устройством как нужно.

<P><A NAME="l1">
<CENTER><H3>Запись на устройство вывода</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspВ отличие от традиционных графических программ DOS программы
Windows никогда не выводят элементы  изображения  непосредственно
на экран  или на принтер,  а записывают их в логическую сущность,
называемую контекстом дисплея. Контекст дисплея - это виртуальная
поверхность  с присущими ей атрибутами,  такими как перо,  кисть,
шрифт,  цвет фона, цвет текста и текущая позиция. Для вашего
приложения,  независимо от того, какое это на самом деле устройство,
все контексты устройства выглядят аналогично.

<P>&nbsp&nbsp&nbsp&nbspКогда вы вызываете функции GDI  для  рисования  в  контексте
устройства,  связанный с этим контекстом драйвер устройства
переводит действия по рисованию в соответствующие команды. Эти
команды  воспроизводят  насколько возможно точно действия рисования на
дисплее, независимо от возможностей самого дисплея. Дисплей может
быть монохромным экраном низкого разрешения или экраном с
четырьмя миллионами цветовых оттенков.

<P>&nbsp&nbsp&nbsp&nbspКонтекст дисплея можно представить себе как холст для
рисования. Окно это - картинка, включающая рамку. Вместо рисования на
картине в рамке вы рисуете на холсте,  а уже затем устанавливаете
его в рамку. Аналогично этому, вы рисуете в контексте дисплея
окна.  Контекст дисплея обладает рядом инструментов рисования,
например, ручки,  кисти и шрифты. Контекст дисплея - это управляемый
Windows элемент,  похожий на элемент окна с тем исключением,  что
контекст    дисплея    не    имеет    соответствующего   элемента
ObjectWindows.

<P>&nbsp&nbsp&nbsp&nbspНужно помнить  о  том,  что контекст устройства представляет
собой только часть устройства, на котором вы реально рисуете.
Хотя вы  можете  рассматривать  вывод в терминах всего окна (рамки,
меню, области клиента) или печатаемой страницы, контекст
устройства охватывает только ту часть,  где вы рисуете - область клиента
окна или печатаемую часть страницы.

<P>&nbsp&nbsp&nbsp&nbspКонтекст устройства - это элемент, управляемый Windows
(аналогично оконному  элементу,  только  контекст устройства не имеет
соответствующего объекта ObjectWindows).

<P><A NAME="l2">
<CENTER><H3>Чем отличаются контексты устройства?</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspДля областей  клиента  окна Windows обеспечивают специальные
контексты устройства,  называемые  контекстами  дисплея.   Вместо
представления самого  устройства,  такого  как экран или принтер,
контекст дисплея позволяет вам интерпретировать  область  клиента
окна как целое устройство.

<P>&nbsp&nbsp&nbsp&nbspНа практике  контекст дисплея вам не требуется
интерпретировать как-то иначе,  чем другой контекст устройства.  Он позволяет
вам работать  так,  как если бы ваше окно было целым устройством,
так что вам не нужно беспокоиться о смещении позиции на экране  и
т.д.

<P><A NAME="l3">
<CENTER><H3>Управление контекстом дисплея</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspДля организации рисования в контексте дисплея сначала  нужно
получить  контекст дисплея для нужного окна.  Требования к памяти
со стороны контекста дисплея очень велики, поэтому можно
одновременно организовать доступ только к пяти контекстам дисплея в
каждом сеансе Windows.  Это значит, что каждое окно не может
поддерживать свой собственный контекст дисплея. Оно получает его только
в случае необходимости и освобождает при первой возможности.  Это
может несколько обескуражить вас, но вы не можете управлять
атрибутами контекста дисплея.  Другое окно и даже  другое  приложение
может  сменить атрибуты контекста дисплея.  Кроме того,  средства
рисования не являются частью памяти контекста дисплея.  Они могут
быть выбраны в контекст дисплея каждый раз при его получении.

<P><A NAME="l4">
<CENTER><H3>Работа с контекстом дисплея</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspОбычно нужно  определять  поле  оконного  объекта для записи
описателя текущего контекста  дисплея,  аналогично  тому,  как  в
HWindow сохраняется описатель окна:

<P><PRE>
     type
       TMyWindows = object(TWindow)
          TheDC: HDC;
           .
           .
           .
       end;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspЧтобы получить  для окна контекст дисплея,  вызовите функцию
Windows GetDC:

<P><PRE>
     TheDC := GetDC(HWindow);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspЗатем вы можете выполнить операцию изображения  в  контексте
дисплея. Вы  можете  использовать  описатель  контекста дисплея в
графических функциях Windows:

<P><PRE>
     LineTo(TheDC, Msg.LParamLo, Msg.LParamHi);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspКак только вы закончите работу с контекстом дисплея,
освободите его с помощью вызова функции ReleaseDC:

<P><PRE>
     ReleaseDC(HWindow, TheDC);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspНе вызывайте GetDC в строке дважды, не включив между
вызовами вызов ReleaseDC. В итоге это приведет к сбою системы при
работе программы, так как она исчерпает все доступные контексты
дисплея.

<P><A NAME="l5">
<CENTER><H3>Что содержится в контексте устройства?</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspКонтекст устройства  содержит набор изобразительных средств,
таких как перья,  кисти и шрифты.  Реально  эти  инструментальные
средства не  существуют.  Они  просто  представляют собой удобный
способ предположений об определенной группе  изобразительных
характеристик.

<P>&nbsp&nbsp&nbsp&nbspПеро, например,  это просто удобный способ интерпретации
характеристик линий  на  устройстве.  Графическая линия между двумя
точками имеет три характеристики: ширину, цвет и стиль (например,
пунктирная линия и линия из точек), которые совместно можно
рассматривать как "перо".  Эти логические группы изобразительных
характеристик значительно упрощают графику в Windows.

<P>&nbsp&nbsp&nbsp&nbspХотя обычно  вам не нужно будет изменять большинство
атрибутов контекста дисплея, важно по крайней мере знать, что в нем
содержится.  Данный раздел кратко описывает некоторые элементы
контекста дисплея,  включая побитовые отображения,  цвета, области и
изобразительные средства.  Некоторые из этих тем также
рассматриваются более подробно в некоторых других разделах данной главы.

<P><A NAME="l6">
<CENTER><H3>Побитовая графика</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspДействительная поверхность контекста дисплея называется
побитовым отображением  (битовым  массивом).  Побитовые отображения
представляют конфигурацию памяти конкретного устройства.
Следовательно,  они зависят от вида адресуемого устройства.  Это создает
проблему, поскольку охраненные для  одного  устройства  побитовые
отображения  будут  несовместимы с другим устройством.  GDI имеет
ряд средств для разрешения этой проблемы, включая
аппаратно-независимые побитовые отображения. Имеются следующие функции GDI,
которые создают    побитовые    отображения:    CreateCompatibleDC,
CreateCompatibleBitmap и CreateDIBitmap.  Имеются следующие
функции GDI  по  манипулированию  побитовыми  отображениями:  BitBlt,
StretchBlt, StretchDIBits и SetDIBitsToDevice.

<P><A NAME="l7">
<CENTER><H3>Изобразительные средства</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspЧтобы выполнить большую часть фактического изображения,
контекст дисплея  использует  три  инструментальных средства:  перо,
кисть и шрифт.

<P><CENTER>Перья</CENTER>

<P>&nbsp&nbsp&nbsp&nbspПеро используется для изображения линий,  дуг и ломаных
линий, представляющих собой множественные линейные сегменты.
Атрибуты пера включают в себя его цвет,  ширину  и  стиль  (например,
пунктирная линия или линия из точек).

<P><CENTER>Кисти</CENTER>

<P>&nbsp&nbsp&nbsp&nbspКисть используется  при закраске замкнутых фигур,  таких как
прямоугольники, прямоугольники с округлыми краями и
многоугольники. Функции,  рисующие  непрерывные формы используют перо для
вычерчивания границ, а кисть - для закраски внутренней области.
Существуют четыре типа кистей - непрерывные,  с засечками, с
образцом побитового отображения и с независимым от устройств  образцом
побитового отображения.

<P><CENTER>Шрифты</CENTER>

<P>&nbsp&nbsp&nbsp&nbspИнструментальное средство  шрифта используется при
изображения в контексте дисплея текста.  Оно задаете высоту  шрифта,  его
ширину, семейство и имя гарнитуры.

<P>&nbsp&nbsp&nbsp&nbspВсе три  инструментальных средства используют для заполнения
пробелов атрибут фонового цвета контекста дисплея.
Изобразительные инструментальные  средства  подробнее  освещаются  в  разделе
"Изобразительные средства" данной главы.

<P><A NAME="l8">
<CENTER><H3>Цвет</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspЦвет, который устройство использует для рисования,  хранится
в цветовой палитре. Если вы желаете добавить цвет, которого нет в
цветовой  палитре,  то его можно добавить.  Более часто вы будете
настраивать драйвер устройства на аппроксимацию нужного цвета
путем  смешивания цветов палитры.  Работа с цветовой палитрой более
подробно рассматривается в разделе  данной  главы  "Использование
цветовой палитры".

<P><A NAME="l9">
<CENTER><H3>Режимы отображения</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspОчень трудно выбрать устройство рисования, когда заранее
неизвестно,  какое устройство будет использоваться для отображения.
Большинство приложений игнорируют эту  проблему  и  предполагают,
что  вполне удовлетворительно будет работать единица рисования по
умолчанию (один элемент изображения).  Однако, некоторые
приложения требуют,  чтобы отображение точно воспроизводило размеры
нужного образа.  Для таких приложений GDI допускает различные режимы
отображения,  некоторые из которых не зависят от аппаратуры.
Каждый из методов распределения имеет  свою  единицу  размерности  и
систему координатной ориентации. Режим распределения по умолчанию
устанавливает начало координат в  левом  верхнем  углу  контекста
дисплея с положительным направлением оси X вправо и положительным
направлением оси Y вниз.  Каждый контекст дисплея имеет  атрибуты
распределения для интерпретации задаваемых вами координат.

<P>&nbsp&nbsp&nbsp&nbspИногда нужно транслировать логические координаты,
используемые вами для рисования,  в физические координаты побитового
отображения. Для большинства приложений начало координат для экрана
это его левый верхний угол,  но для окна началом  координат будет
левый  верхний угол области клиента.  Некоторые окна прокручивают
свою поверхность клиента так,  что начало координат не будет даже
находиться  в  области  клиента.  Некоторые  функции GDI работают
только в конкретной системе координат, поэтому преобразование
координат просто необходимо. В GDI имеется ряд функций для
подобного пересчета координат:  ScreenToClient, ClientToScreen, DPToLP и
LPToDP.

<P><A NAME="l10">
<CENTER><H3>Обрезание областей</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspДля предотвращения рисования  вне  заданной  области  каждый
контекст  дисплея  имеет атрибут области вырезанного изображения.
Область вырезанного изображения может быть сложным
многоугольником  или  эллипсом,  внутри которого и может происходить
действительное рисование на виртуальной поверхности  контекста  дисплея.
Для  большинства приложений выделяемая по умолчанию область
вырезанного изображения будет вполне достаточной.  Изменять  эту
область придется только для приложений, которые воспроизводят
некоторые специальные визуальные эффекты.

<P><A NAME="l11">
<CENTER><H3>Инструментальные средства рисования</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspКонтекст дисплея  управляет  отображением графики на экране.
Для иного способа отображения графики можно  изменить
инструментальные средства,  с помощью которых создается изображение.
Атрибуты инструментальных средств задают проявление изображений с
помощью функций GDI,  например,  LineTo,  Rectange и TextOut. Перья
задают внешний вид линий,  кисти задают внешний  вид  закрашенных
областей и шрифт задает внешний вид изображаемого текста.

<P>&nbsp&nbsp&nbsp&nbspДля задания атрибутов инструмента программа Windows выбирает
логический инструмент в контекст дисплея.  Логический  инструмент
создается  вашей  программой  путем заполнения полей определенной
записи, TLogPen, TLogBrush или TLogFont. Текущий инструмент - это
инструмент, определенный  в  Windows,  представляющий самый общие
варианты атрибута, например, непрерывное черное перо, серая кисть
или системный шрифт.

<P><A NAME="l12">
<CENTER><H3>Основные инструментальные средства</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspОсновные инструментальные средства  создаются  функцией  GDI
GetStockObject. Например:

<P><PRE>
     var
       TheBrush: HBrush
     begin
       TheBrush:=GetStockObject(LtGray_Brush);
        .
        .
        .
     end;
</PRE><P>

где LtGray_Brush - это целая  константа,  определенная  в  модуле
WinTypes в ObjectWindows. Приведем список всех имеющихся констант
основного инструментального средства:

<P><CENTER><TABLE BORDER=2>
<CAPTION ALIGN=TOP>Основные инструменты рисования. Таблица 17.1</CAPTION>
<TR><TH>Кисти</TH><TH>Перья</TH><TH>Шрифты</TH></TR>
<TR><TD>White_Brush     </TD><TD>White_Pen      </TD><TD>OEM_Fixed_Font      </TD></TR>
<TR><TD>LtGray_Brush    </TD><TD>Black_Pen      </TD><TD>ANSI_Fixed_Font     </TD></TR>
<TR><TD>Gray_Brush      </TD><TD>Null_Pen       </TD><TD>ANSI_Var_Font       </TD></TR>
<TR><TD>DkGray_Brush    </TD><TD>               </TD><TD>System_Font         </TD></TR>
<TR><TD>Black_Brush     </TD><TD>               </TD><TD>Device_Default_Font </TD></TR>
<TR><TD>Null_Brush      </TD><TD>               </TD><TD>System_Fixed_Font   </TD></TR>
<TR><TD>Hoolow_Brush    </TD><TD>               </TD><TD>                    </TD></TR>
</TABLE></CENTER>

<P>&nbsp&nbsp&nbsp&nbspВ отличие  от  логических  инструментальных средств основные
инструментальные средства не удаляются после использования.

<P><A NAME="l13">
<CENTER><H3>Логические инструментальные средства</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspЗаписи логических   инструментов,   TLogPen,   TLogBrush   и
TLogFont,  содержат поля для хранения каждого атрибута
инструмента.  Например,  TLogPen.lopnColor  содержит значение цвета ручки.
Каждый тип записи определяет свой  собственный  набор  атрибутов,
соответствующий типу инструмента.

<P><A NAME="l14">
<CENTER><H3>Логические перья</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspВы можете  создавать  логические  перья  с  помощью  функций
Windows CreatePen или CreatePenInderect. Например:

<P><PRE>
     ThePen := CreatePen(ps_Dot, 3, RGB(0, 0, 210));
     ThePen := CreatePenInderect(@ALogPen);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspОпределение записи TLogPen имеет следующий вид:

<P><PRE>
     TLogPen = record
        lopnStyle: Word;
        lopnWidth: TPoint;
        lopnColor: Longint;
     end;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspПоле стиля,  lopnStyle,  содержит константу,  задающую стиль
линии.<P>

<CENTER>
<IMG SRC="ris34.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris34.gif"><BR>
Рис.17.1 Стили линий для пера.</CENTER><P>

<P>&nbsp&nbsp&nbsp&nbspПоле толщины,  lopnWidth, содержит точку, координата x
которой задает толщину линии в координатах устройства. На экране VGA,
если задано значение 0, то будет рисоваться линия толщиной в один
элемент изображения.  Значение координаты  y  игнорируется.  Поле
цвета, lopnColor, содержит значение Longint, байты которого
задают величины интенсивности основных цветов (красного,  зеленого  и
синего),  смешение которых и дает нужный цвет. Значение lopnColor
должно иметь вид $00bbggrr,  где bb - значение синего цвета, gg
значение зеленого цвета,  а rr - значение красного цвета.
Доступный диапазон интенсивности для каждого первичного цвета от  0  до
255,  или  от  0 до FF в шестнадцатиричном исчислении.  Следующая
таблица показывает некоторые примеры значений цвета:<P>

<CENTER><TABLE BORDER=2>
<CAPTION ALIGN=TOP>Примеры значений цвета. Таблица 17.2</CAPTION>
<TR><TH>Значение</TH><TH>Цвет</TH></TR>
<TR><TD>$00000000   </TD><TD>черный      </TD></TR>
<TR><TD>$00FFFFFF   </TD><TD>белый       </TD></TR>
<TR><TD>$000000FF   </TD><TD>красный     </TD></TR>
<TR><TD>$0000FF00   </TD><TD>зеленый     </TD></TR>
<TR><TD>$00FF0000   </TD><TD>синий       </TD></TR>
<TR><TD>$00808080   </TD><TD>серый       </TD></TR>
</TABLE></CENTER>

<P>&nbsp&nbsp&nbsp&nbspВ качестве  альтернативы для воспроизведения цвета можно
использовать  функцию  RGB.  RGB(0,0,0)  возвратит   черный   цвет,
RGB(255,0,0) возвратит красный и т.д.

<P><A NAME="l15">
<CENTER><H3>Логические кисти</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspВы можете  создавать  логические  кисти  с  помощью  функций
Windows           CreateHatchBrush,           CreatePatternBrush,
CreateDIBPatternBrush или CreateBrushInderect. Например:

<P><PRE>
     TheBrush := CreateHatchBrush(hs_Vertical, RGB(0, 255, 0));
     TheBrush := CreateBrushInderect(@ALogBrush);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspОпределение записи TLogBrush имеет следующий вид:

<P><PRE>
     TLogBrush = record
       lbStyle: Word;
       lbColor: Longint;
       lbHatch: Integer;
     end;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspПоле стиля, lbStyle, содержит константы, задающие стиль
кисти:<P>

<UL>
<LI>bs_DIBPattern указывает,  что образец кисти задан
аппаратно-независимым побитовым отображением.

<LI>bs_Hatched задает один из  заранее  определенных  образцов
штриховки (см. lbHatch).

<LI>bs_Hollow - это пустая кисть.

<LI>bs_Pattern  использует левый верхний угол 8 на 8 элементов
побитового отображения,  которое находится в этот момент в
памяти.

<LI>bs_Solid - это непрерывная кисть.
</UL>

<P>&nbsp&nbsp&nbsp&nbspПоле lbColor  содержит  значение  цвета,  аналогично  записи
TLogPen.  Это поле игнорируется кистями со  стилями  bs_Hollow  и
bs_Pattern.

<P>&nbsp&nbsp&nbsp&nbspПоле lbHatch  содержит  целую  константу,  задающую  образец
штриховки для   кисти   со   стилем   bs_Hatched.   Если    стиль
bs_DIBPattern, то lbHatch содержит описатель побитового
отображения.<P>

<CENTER><IMG SRC="ris35.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris35.gif"><BR>
Рис. 17.2 Стили штриховки для кисти.</CENTER><P>

<P><A NAME="l16">
<CENTER><H3>Логические шрифты</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspВы можете создавать  логические  шрифты  с  помощью  функций
Windows CreateFont или CreateFontInderect.

<P>&nbsp&nbsp&nbsp&nbspОпределение записи TLogBrush следующее:

<P><PRE>
     TLogFont = record
         lfHight: Integer;
         lfWidht: Integer;
         lfEscapement: Integer;
         lfOrientation: Integer;
         lfWeight: Integer;
         lfItalic: Byte;
         lfUnderline: Byte;
         lfStrikeOut: Byte;
         lfCharSet: Byte;
         lfOutPrecision: Byte;
         lfClipPrecision: Byte;
         lfQuality: Byte;
         lfPitchAndFamily: Byte;
         lfFaceName: array[0..lf_FaceSize - 1] of Byte;
     end;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspПри использовании TLogFont для создания  шрифта  вы  задаете
атрибуты нужного вам шрифта. Однако, ваша программа не использует
эту информацию для генерации шрифта на экране.  Вместо этого  она
отображает запрос  экранного шрифта  в текущий экранный шрифт
сеанса Windows.

<P>&nbsp&nbsp&nbsp&nbspПоле lfHight задает необходимую высоту шрифта.  Нулевое
значение  устанавливает размер по умолчанию.  Положительное значение
есть высота элемента в логических единицах.  Отрицательное
значение воспринимается как положительное.

<P>&nbsp&nbsp&nbsp&nbspПоле lfWidht  задает  нужную ширину букв в единицах
устройства. Если  задан  ноль,  то  коэффициент относительного удлинения
сохраняется.

<P>&nbsp&nbsp&nbsp&nbspДля поворачиваемого  текста  lfEscapement  задает значение в
десятых долях градуса, на которое поворачивается текст против
часовой  стрелки.  lfOrientation делает аналогичный поворот каждого
символа.

<P>&nbsp&nbsp&nbsp&nbspПараметр lfWeight задает нужный  вес  символов.  В  качестве
значений   можно   использовать  константы  fw_Light,  fw_Normal,
fw_Bold и fw_DontCare.

<P>&nbsp&nbsp&nbsp&nbspДля трех  атрибутов  шрифта  -   lfItalic,   lfUnderline   и
lfStrikeOut  - нужно задать ненулевые значения.

<P>&nbsp&nbsp&nbsp&nbspВ поле lfCharSet требуется задать конкретный набор символов,
ANSI_CharSet, OEM_CharSet или Symbol_CharSet. Набор символов ANSI
содержится  в "Руководстве пользователя по Microsoft Windows",  в
Приложении B. OEM_CharSet является системно-зависимым.

<P>&nbsp&nbsp&nbsp&nbspПоле lfOutPrecision задает,  как точно  создаваемый  Windows
шрифт должен соответствовать запросам на размеры и
позиционирование. Значение  поля  по  умолчанию  -  Out_Default_Precis.   Поле
lfClipPrecision задает  способ рассмотрения частично видимых
символов. Значение поля по умолчанию Clip_Default_Precis.

<P>&nbsp&nbsp&nbsp&nbspПоле lfQuality показывает как точно предоставляемый  Windows
шрифт соответствует запрошенным атрибутам шрифта.  Может быть
установлено    значение    Default_Quality,    Draft_Quality    или
Proof_Quality.  Для значения Proof_Quality жирные,  подчеркнутые,
наклонные шрифты и шрифты с надпечаткой синтезируются,  даже если
их нет.  Поле lfPitchAndFamily задает шаг и семейство шрифта. Оно
может быть результатом логической операции  or  между  константой
шага и константой семейства.<P>

<CENTER><TABLE BORDER=2>
<CAPTION ALIGN=TOP>Константы шага и семейства шрифта. Таблица 17.3</CAPTION>
<TR><TH>Константы шага</TH><TH>Константы семейства</TH></TR>
<TR><TD>Default_Pitch     </TD><TD>ff_Modern             </TD></TR>
<TR><TD>Fixed_Pitch       </TD><TD>ff_Roman              </TD></TR>
<TR><TD>Variable_Pitch    </TD><TD>ff_Script             </TD></TR>
<TR><TD>                  </TD><TD>ff_Swiss              </TD></TR>
<TR><TD>                  </TD><TD>ff_Decorative         </TD></TR>
<TR><TD>                  </TD><TD>ff_DontCare           </TD></TR>
</TABLE></CENTER>

<P>&nbsp&nbsp&nbsp&nbspИ, наконец,  lfFaceName - это строка,  которая задает
запрошенный вид букв.  Если задано значение 0, то вид букв будет
строиться на основании значений других полей TLogFont.  Приведем
несколько примеров исходного кода, определяющего записи TLogFont:

<P><PRE>
     procedure MyWindow.MakeFont;
     var
       MyLogFont: TLogFont;
     begin
       with MyLogFont do
       begin
         lfHight := 30;
         lfWidht := 0;
         lfEscapement := 0;
         lfOrientation := 0;
         lfWeight := fw_Bold;
         lfItalic := 0;
         lfUnderline := 0;
         lfStrikeOut := 0;
         lfCharSet := ANSI_CharSet;
         lfOutPrecision := Out_Default_Precis;
         lfClipPrecision := Clip_Default_Precis;
         lfQuality := Default_Quality;
         lfPitchAndFamily := Variable_Pitch or ff_Swiss;
         StrCopy(@FaceName, 'Helv');
      end;
      TheFont := CreateFontInderect(@MyLogFont);
     end;

     procedure MyWindow.MakeFont;
     var
       MyLogFont: TLogFont;
     begin
       with MyLogFont do
       begin
         lfHight := 10;
         lfWidht := 0;
         lfEscapement := 0;
         lfOrientation := 0;
         lfWeight := fw_Normal;
         lfItalic := Ord(True);
         lfUnderline := Ord(True);
         lfStrikeOut := 0;
         lfCharSet := ANSI_CharSet;
         lfOutPrecision := Out_Default_Precis;
         lfClipPrecision := Clip_Default_Precis;
         lfQuality := Default_Quality;
         lfPitchAndFamily := Fixed_Pitch or ff_DontCare;
         StrCopy(@FaceName, 'Courier');
      end;
      TheFont := CreateFontInderect(@MyLogFont);
     end;

     procedure MyWindow.MakeFont;
     var
       MyLogFont: TLogFont;
     begin
       with MyLogFont do
       begin
          lfHight:=30;
          lfWidht:=0;
          lfEscapement:=0;
          lfOrientation:=0;
          lfWeight:=fw_Normal;
          lfItalic:=0;
          lfUnderline:=0;
          lfStrikeOut:=0;
          lfCharSet:=Symbol_CharSet;
          lfOutPrecision:=Out_Default_Precis;
          lfClipPrecision:=Clip_Default_Precis;
          lfQuality:=Proof_Quality;
          lfPitchAndFamily:=Fixed_Pitch or ff_Roman;
          StrCopy(@FaceName, 'Rmn');
      end;
        TheFont:=CreateFontInderect(@MyLogFont);
     end;
</PRE>

<P><A NAME="l17">
<P><CENTER><H3>Использование изобразительных инструментальных средств</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspКонтекст дисплея позволяет вам рисовать в окне и, кроме
этого,  он содержит инструментальные средства рисования: перья,
кисти, шрифты и палитры, которые вы используете для рисования текста
и изображений.  При рисовании линии в контексте дисплея линия
выводится со следующими атрибутами текущего пера: цвет, стиль
(непрерывная,  пунктирная и т.п.) и толщина. При закрашивании области
она выводится со следующими атрибутами текущей кисти:  образец  и
цвет. При рисовании текста в контексте дисплея он выведется с
атрибутами текущего шрифта:  шрифт (Modern,  Roman,  Swiss и т.п.),
размер,  стиль (наклонный, жирный и т.п.). Палитра содержит набор
текущих доступных цветов.

<P>&nbsp&nbsp&nbsp&nbspКонтекст дисплея  содержит по одному типу каждого
инструментального средства рисования.  Вновь полученный  контекст  дисплея
содержит набор инструментальных средств,  используемых по
умолчанию:  тонкое черное перо,  непрерывная  черная  кисть,  системный
шрифт и палитра по умолчанию.  Если этот набор вас устраивает, то
нет необходимости его изменять.

<P>&nbsp&nbsp&nbsp&nbspДля изменения  набора инструментальных средств по умолчанию,
нужно создать новый инструментальный элемент и выбрать его в
контекст дисплея.  Например, при выборе новой ручки старая
автоматически удаляется.  Мы рекомендуем вам сохранять старые
инструментальные средства  и повторно устанавливать их после окончания
использования новых:

<P><PRE>
     var
        NewPen, OldPen: HPen;
        TheDC: HDC;
     begin
{ задать ширину пера 10 }
        NewPen := CreatePen(ps_Solid, 10, RGB(0, 0, 0));
        TheDC := GetDC(AWindow^.HWindow);
        OldPen := SelectObject(TheDC, NewPen);
{ выполнить черчение }
        SelectObject(TheDC, OldPen);
        ReleaseDC(AWindow^.HWindow, TheDC);
        DeleteObject(NewPen);
     end;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspКак показано в данном примере,  новый  инструмент  рисования
должен  быть создан,  а затем удален.  Подобно контексту дисплея,
элементы хранятся в памяти Windows.  Если их не удалить, это
приводит  к  потерям памяти и возможности возникновения сбоя.  Как и
для контекста дисплея, вы должны хранить описатели
инструментальных средств  рисования  в переменных типа HPen,  HBrush,  HFont и
HPalette.

<P>&nbsp&nbsp&nbsp&nbspФункция Windows DeleteObject удаляет инструментальные
средства  рисования  из  памяти Windows.  Ни в коем случае не удаляйте
инструментальные средства рисования, которые выбраны в данный
момент в контекст дисплея!

<P>&nbsp&nbsp&nbsp&nbspКонтекст дисплея  может хранить только по одному инструменту
рисования каждого типа в данный  момент  времени,  поэтому  нужно
отслеживать   доступные  инструментальные  средства  отображения.
Очень важно удалить их все до завершения работы  вашего
приложения. Один  из методов,  (использован в примере Главы 2) состоит в
определении поля объекта окна с именем ThePen для хранения
описателя текущего пера. Когда пользователь выбирает новый стиль пера,
создается новое перо,  а старое удаляется. Следовательно,
окончательное  перо будет удалено методом основного окна CanClose.  Вам
не нужно удалять набор  инструментальных  средств  по  умолчанию,
поставляемый во вновь полученном контексте дисплея.

<P>&nbsp&nbsp&nbsp&nbspЕсть два способа создания новых инструментальных средств
рисования.  Самый простой способ состоит в использовании
существующего альтернативного инструмента,  называемого основным или
опорным. Список основных инструментальных средств приведен в  Таблице
17.1.

<P>&nbsp&nbsp&nbsp&nbspДля установки основного инструментального средства в объекте
контекста дисплея используются методы SetStockPen, SetStockBrush,
SetStockFont и SetStockPalette. Например:

<P><PRE>
     ThePen:=GetStockObject(Black_Pen);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspНе удаляйте основные инструменты из памяти Windows,
поскольку вы будете настраивать их. Иногда возникает ситуация, когда нет
основного инструмента, который имел бы нужный вам атрибут.
Например,  все основные перья воспроизводят тонкие линии, а вам
требуется толстая.  В этом случае имеется два способа создания
настроенных инструментальных средств рисования.  Один способ состоит  в
вызове  функций Windows CreatePen,  CreateFont,  CreateSolidBrush
или CreateDIBPatternBrush.  Эти функции используют параметры,
которые описывают нужный инструмент, и возвращают описатель
инструментального   средства,   который    используется    в    вызовах
SelectObject.

<P>&nbsp&nbsp&nbsp&nbspДругой способ создания настроенных инструментальных средств
состоит  в построении описания атрибутов логического инструмента.
Логический  инструмент  реализуется  структурами  данных  Windows
TLogPen,  TLogBrush,  TLogFont и TLogPalette.  Например,  TLogPen
имеет поля для хранения толщины цвета  и  стиля.  После  создания
записи данных логического инструмента,  она передается в качестве
параметра      в      CreatePenInderect,     CreateBrushInderect,
CreateFontInderect или CreatePalette. Эти функции возвращают
описатели инструментального средства которые могут быть использованы
в вызовах SelectObject.  В данном примере  устанавливается  синее
перо для изображения в контексте дисплея окна:

<P><PRE>
     procedure SampleWindow.ChangePenToBlue;
     var
        ALogPen: TLogPen;
        ThePen: HPen;

     begin
        ALogPen.lopnColor:=RGB(0, 0, 255);
        ALogPen.lopnStyle:=ps_Solid;
        ALogPen.lopnWidth.X:=0;
        ALogPen.lopnWidth.Y:=0;
        ThePen:=CreatePenInderect(@ALogPen);
        SelectObject(TheDC, ThePen);
     end;
</PRE>

<P><A NAME="l18">
<CENTER><H3>Отображение графики в окнах</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspРисование - это процесс отображения контекста окна.
Приложение Windows отвечает за рисование его окон при их первом
появлении и их изменении, например, после восстановления из пиктограммы
или перекрытия другими окнами.  Windows не обеспечивает
автоматического рисования  контекста  окон,  она только информирует окно,
когда ему нужно нарисовать себя.  Данный раздел  показывает,  как
рисовать в окне, объясняет механизм рисования и объясняет
использование контекста дисплея.

<P>&nbsp&nbsp&nbsp&nbspВ данном разделе термин "рисование" относится к  отображению
графики в окне. Рисование - это автоматическое отображение
графики при первом появлении или изменении окна.  С другой стороны
рисование -  это процесс создания и отображения специфических
изображений в другие моменты времени под управлением  программы.  Под
графикой понимается как текст, так и элементы изображения,
например, побитовые отображения и прямоугольники.

<P><A NAME="l19">
<CENTER><H3>Изображение окон</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspКогда возникает необходимость нарисовать окно, оно
становится запрещенным.  Это значит что изображение дисплея не
соответствует  действительности и должно быть изменено.  Это происходит в
момент первоначального отображения окна,  восстановления из
пиктограммы  или  удаления  другого окна,  которое перекрывало часть
данного окна.  Во всех этих случаях  Windows  посылает  сообщение
wm_Paint соответствующему приложению. Это сообщение автоматически
вызывает метод Paint  вашего  окна.  Один  из  параметров  Paint,
PaintDC, представляет собой контекст дисплея, который
используется для рисования.

<P>&nbsp&nbsp&nbsp&nbspМетод TWindow Paint  ничего  не  рисует,  поскольку  объекты
TWindow не имеют графики для рисования.  В типе вашего окна
определим метод Paint, который будет вызывать методы и функции,
изображающие в окне текст и графику.

<P>&nbsp&nbsp&nbsp&nbspЕдинственное, что  вы  можете  сделать с контекстом дисплея,
это выбрать в него новый инструмент  рисования,  например,  перья
других цветов или кисти других образцов. Вам придется указать эти
инструменты в контексте дисплея рисования вашего метода Paint.

<P>&nbsp&nbsp&nbsp&nbspПосле завершения  работы метода Paint контекст дисплея
рисования автоматически освобождается.

<P><A NAME="l20">
<CENTER><H3>Стратегия графики</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspМетод Paint отвечает за рисование текущего содержимого  окна
в любой момент времени, включая первое появление этого окна.
Следовательно,  метод Paint должен уметь рисовать  все  "постоянные"
изображения окна. Кроме того, он должен уметь восстанавливать
любые изображения,  добавленные в окно после его первого появления.
Для  воспроизведения этой "динамической" графики метод Paint
должен иметь доступ к инструкциям или данным, с помощью которых было
создано изображение.

<P>&nbsp&nbsp&nbsp&nbspВы можете  выбрать один из двух возможных вариантов.  Первый
подход состоит в выделении нескольких графических методов  и  при
динамическом  рисовании вызывать их из метода Paint.  Другой
подход, показанный в примере Главы 3, состоит в хранении данных,
относящихся  к  графическому контексту окна,  в полях объекта этого
окна.  Эти данные могут включать, например, координаты, формулы и
побитовые распределения. Затем метод Paint повторно вызывает
графические функции,  которые нужны для преобразования этих данных в
изображения.

<P>&nbsp&nbsp&nbsp&nbspИспользуя эти  стратегии  и способность объекта хранить свои
собственные данные и функции вы можете разрабатывать очень
развитые и впечатляющие графические приложения.

<P><A NAME="l21">
<CENTER><H3>Рисование в окнах</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspДля рисования  любого  текста или изображения в объекте окна
сначала нужно получить контекст дисплея. После рисования контекст
дисплея нужно освободить. (В одном сеансе Windows доступны только
пять элементов контекста дисплея.) Вы можете использовать
описатель  контекста дисплея  в  качестве  аргумента любой графической
функции Windows.

<P><CENTER>Вызов графических функций окна</CENTER>

<P>&nbsp&nbsp&nbsp&nbspОдно из правил GDI состоит в том, что для работы функций
необходимо в качестве аргумента задавать контекст  дисплея.  Обычно
вы  будете  вызывать эти функции из методов типа окна.  Например,
TextOut - это функция рисования текста на контексте дисплея в
заданном месте:

<P><PRE>
     TheDC := GetDC(HWindow);
     TextOut(TheDC, 50, 50, 'Sample Text', 11);
     ReleaseDC(HWindow, TheDC);
</PRE>

<P><A NAME="l22">
<CENTER><H3>Графические функции GDI</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspДанный раздел описывает различные вызовы API, которые вы
можете использовать для рисования изображений в окне.

<P><A NAME="l23">
<CENTER><H3>Функции изображения текста</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspФункция рисования текста использует для  рисования  заданный
текущий  шрифт контекста дисплея.  Функция TextOut рисует текст в
заданной точке.  TextOut выравнивает текст в зависимости от
текущих значений флагов форматирования текста.  По умолчанию
происходит выравнивание слева.  Текущий метод выравнивания можно
посмотреть  с помощью функции GetTextAlign и установить с помощью
функции SetTextAlign.

<P>&nbsp&nbsp&nbsp&nbspФункция TextOut - это самая часто используемая функция
рисования текста. Используя установленные по умолчанию флаги
форматирования текста,  данный метод Paint рисует выравненный слева
массив  символов,  левый  верхний  угол  которого  имеет  координаты
(10,15).

<P><PRE>
     procedure TMyWindow.Paint(PaintDC: HDC;
                               var PaintINfo: TPaintStruct);
     var
        MyTextString: array[0..20] of Char;
     begin
        StrCopy(MyTextString, 'Hello, World');
        TextOut(PaintDC, 10, 15, MyTextString,
                               StrLen(MyTextString));
     end;
</PRE><P>

<CENTER><IMG SRC="ris36.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris36.gif"><BR>
Рис. 17.3 Результат выполнения функции TextOut.</CENTER><P>

<P><A NAME="l24">
<CENTER><H3>Функции рисования линий</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspФункции рисования линии используют  для  рисования  заданное
текущее перо контекста дисплея.  Большинство линий рисуется с
использованием функций MoveTo и LineTo. Эти функции воздействуют на
атрибут контекста  дисплея  - текущую позицию.  Если использовать
аналогию с карандашом и листом бумаги,  то  текущая  позиция  это
точка, где карандаш касается бумаги.

<P><CENTER>Функции MoveTo и LineTo</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция MoveTo перемещает текущую позицию в заданные
координаты.  Функция LineTo рисует линию из текущей позиции к  точке  с
заданными координатами.  Заданные координаты затем становятся
текущей позицией.  Следующий метод Paint рисует линию от  (100,150)
до (10,15).

<P><PRE>
      procedure TMyWindow.Paint(PaintDC: HDC; var PaintINfo:
                                TPaintStruct);
      begin
        MoveTo(PaintDC, 100, 150);
        LineTo(PaintDC, 10, 15);
      end;
</PRE>

<P><CENTER>
<IMG SRC="ris37.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris37.gif"><BR>
Рис. 17.4. Результат выполнения функции LineTo.</CENTER><P>

<P><CENTER>Функция PolyLine</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция Polyline рисует последовательность линий,
соединяющих заданные точки.  По действию она аналогична выполнению
последовательности функций MoveTo и LineTo, однако, Polyline выполняет
эту  операцию  намного быстрее и никак не воздействует на текущую
позицию пера. Следующий метод Paint рисует прямой угол.

<P><PRE>
     procedure TMyWindow.Paint(PaintDC: HDC; var PaintInfo:
                               TPaintStruct);
     var
      Points: array[0..2] of TPoint;
     begin
      Points[0].X:=10;
      Points[0].Y:=15;
      Points[1].X:=10;
      Points[1].Y:=150;
      Points[2].X:=100;
      Points[2].Y:=150;
      Polyline(PaintDC, @Points, 3);
     end;
</PRE>

<CENTER><IMG SRC="ris38.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris38.gif">
Рис. 17.5. Результат выполнения функции Polyline.</CENTER><P>

<P><CENTER>Функция Arc</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция Arc рисует дуги по периметру эллипса,  ограниченного
заданным прямоугольником. Дуга начинается в точке пересечения
эллипса и линии из центра эллипса в заданную точку начала. Дуга
рисуется против часовой стрелки до тех пор,  пока она  не достигнет
точки  пересечения  эллипса с линией из центра эллипса к заданной
точке конца.

<P>&nbsp&nbsp&nbsp&nbspСледующий метод Paint рисует верхнюю четверть  окружности  с
началом в (40,25) и окончанием в (10,25),  используя
ограничивающий прямоугольник (10,10),  (40,40),  начальную точку (0,0) и
конечную точку (50,0). Действие производится даже в том случае,
если заданная начальная и конечная точка не лежат на дуге.

<P><PRE>
     procedure TMyWindow.Paint(PaintDC: HDC;
                               var PaintInfo: TPaintStruct);
     begin
        Arc(PaintDC, 10, 10, 40, 40, 50, 0, 0, 0);
     end;
</PRE>

<P><A NAME="l25">
<CENTER><H3>Изображение фигур</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspФункции изображения  фигур используют текущее перо заданного
контекста дисплея для изображения периметра и текущую  кисть  для
закраски внутренней области. На текущую позицию они не влияют.

<P><CENTER>Функция Rectangle</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция Rectangle рисует прямоугольник от его левого
верхнего угла к правому нижнему.  Например,  следующий оператор  метода
Paint рисует прямоугольник от (10,15) до (100,150).

<P><PRE>
     Rectangle(PaintDC, 10, 15, 100, 150);
</PRE>

<CENTER><IMG SRC="ris39.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris39.gif"><BR>
Рис. 17.6. Результат выполнения функции Rectangle.</CENTER><P>

<P><CENTER>Функция RoundRect</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция RoundRect рисует прямоугольник со скругленными
углами.  Скругления углов определены как четверти эллипса.  Например,
следующий оператор метода Paint рисует прямоугольник  от  (10,15)
до  (100,150),  углы  которого будут скруглены четвертями эллипса
шириной 9 и высотой 11.

<P><PRE>
     RoundRect(PaintDC, 10, 15, 100, 150, 9, 11);
</PRE>

<P><CENTER>Функция Ellipse</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция Ellipse рисует эллипс, задаваемый ограничивающим его
прямоугольником.  Следующий пример рисует эллипс в прямоугольнике
от (10,15) до (110,70).

<P><PRE>
     Ellipse(PaintDC, 10, 50, 100, 150);
</PRE>

<P><CENTER>Функции Pie и Chord</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункции Pie и Chord рисуют секторы эллипса. Они рисуют дугу,
подобно функции Arc. Однако, результатом Pie и Chord будут
области. Функция Pie соединяет центр эллипса с его граничными точками.
Следующая функция Pie рисует верхнюю четверть круга, заключенного
в прямоугольник от (10,10) до (40,40).

<P><PRE>
     Pie(PaintDC, 10, 10, 40, 40, 50, 0, 0, 0);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspФункция Chord соединяет две граничные точки дуги.

<P><PRE>
     Chord(PaintDC, 10, 10, 40, 40, 50, 0, 0, 0);
</PRE>

<P><CENTER>Функция Polygon</CENTER>

<P>&nbsp&nbsp&nbsp&nbspФункция Polygon рисует непрерывную  последовательность
сегментов линий,  аналогично функции Polyline, но в конце работы
замыкает область,  рисуя линию от последней заданной точки к первой
заданной точке. И, наконец, он заполняет полученный многоугольник
текущей кистью, используя установленный режим закрашивания
многоугольника. Следующий метод Paint рисует и закрашивает
прямоугольный треугольник.

<P><PRE>
     procedure TMyWindow.Paint(PaintDC: HDC;
                               var PaintInfo: TPaintStruct);
     var
      Points: array[0..2] of TPoint;
     begin
      Points[0].X:=10;
      Points[0].Y:=15;
      Points[1].X:=10;
      Points[1].Y:=150;
      Points[2].X:=100;
      Points[2].Y:=150;
      Polygon(PaintDC, @Points, 3);
     end;
</PRE>

<P><CENTER><IMG SRC="ris40.gif" tppabs="http://www.neic.nsk.su/rus/tech/bpw/ris40.gif"><BR>
Рис. 17.7. Результат выполнения функции Polygon.</CENTER><P>

<P><A NAME="l26">
<CENTER><H3>Использование палитр</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspНекоторые типы дисплейных устройств компьютера  могут
выводить  множество цветов,  но только ограниченное их число в каждый
момент времени. Системная или физическая палитра - это группа или
набор цветов, которые в данный момент доступны дисплею для
одновременного отображения.  Windows дает вашему приложению  частичное
управление цветами, входящими в системную палитру устройства.
Если ваше приложение использует только простые цвета,  то  вам  нет
необходимости непосредственно использовать палитру.

<P>&nbsp&nbsp&nbsp&nbspОднако, изменение  палитры системы воздействует на все
изображение,  имеющееся на экране,  включая другие  приложения.  Одно
приложение  может  вызвать  вывод всех других приложений в
некорректных цветах. Администратор палитры Windows разрешает эту
проблему,  согласовывая  изменения  системной палитры с приложениями.
Windows предоставляет каждому приложению свою логическую палитру,
которая представляет собой группу цветов, используемых
приложением. Администратор палитры связывает запрошенные логической
палитрой цвета с имеющимися цветами системной палитры.  Если
запрошенный цвет отсутствует в системной палитре,  администратор  палитры
может добавить его.  Если в логической палитре задано больше
цветов,  чем может содержаться в системной палитре,  то для
дополнительных цветов подбирается максимально похожий цвет системной
палитры.

<P>&nbsp&nbsp&nbsp&nbspКогда приложение становится  активным,  имеется  возможность
заполнить  системную  палитру цветами из логической палитры.  Это
действие может повлиять на распределение цветов,  заданных
логическими  палитрами других приложений.  В любом случае Windows
резервирует 20 цветов в системной палитре для общего  представления
цветовой гаммы всех приложений и самого Windows.

<P><A NAME="l27">
<CENTER><H3>Установка палитры</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspЛогические палитры являются инструментами рисования,  такими
же  как  перья  и  кисти,  описанные  в разделе "Инструментальные
средства изображения".  Для создания логической палитры
используется  функция  CreatePalette,  которая  берет указатель на запись
данных LogPalette,  создает новую палитру и возвращает ее
описатель, который  передается  в  SelectPalette  для выбора палитры в
контекст дисплея.  Запись TLogPalette содержит поля номера версии
Windows (в настоящее время $0300), число элементов палитры и
массив элементов палитры.  Каждый элемент палитры - это запись  типа
TPaletteEntry. Тип TPaletteEntry имеет три байтовых поля для
спецификации цвета (peRed,  peGreen и peBlue) и одно поле для флагов
(peFlags).

<P>&nbsp&nbsp&nbsp&nbspGetStockObject(Default_Palette) создает  палитру  по
умолчанию, состоящую из 20 цветов, которые всегда присутствуют в
палитре системы.

<P>&nbsp&nbsp&nbsp&nbspПосле выбора   палитры   в   контекст   дисплея   с  помощью
SelectPalette,  он должен до использования "реализовать" ее.  Это
делается с помощью функции Windows RealizePalette:

<P><PRE>
     ThePalette := CreatePalette(@ALogPalette);
     SelectPalette(TheDC, ThePalette, 0);
     RealizePalette(TheDC);
</PRE>

<P>&nbsp&nbsp&nbsp&nbspRealizePalette помещает  цвета из вашей логической палитры в
системную палитру устройства. Сначала Windows проверяет
соответствие цветов с уже имеющимися в системной палитре,  а затем
добавляет ваши новые цвета в палитру системы, если для этого есть
место.  Цветам,  которым не нашлись идентичные цвета в системной
палитре, подбирается наиболее соответствующий цвет из палитры
системы.  Ваше приложение должно реализовать свою палитру до
рисования, как это делается для других инструментальных средств
рисования.

<P><A NAME="l28">
<CENTER><H3>Рисование с палитрами</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspПосле реализации палитры вашего приложения,  оно может
осуществлять  рисование  с использованием его цветов.  Цвета палитры
можно задавать прямо или косвенно.  Для прямого задания цвета
используется  индекс палитры,  TColorRef.  Индекс палитры TColorRef
есть значение типа Longint,  где старший байт установлен в  1,  а
индекс элемента логической палитры содержится в двух младших
байтах. Например, $01000009 задает девятый элемент логической
палитры. Это значение можно использовать везде, где ожидается аргумент
TColorRef. Например:

<P><PRE>
     ALogPen.lopnColor := $01000009;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspЕсли ваше дисплейное устройство допускает использование
полного  24-битового  цвета без системной палитры,  то использование
индекса палитры неоправданно ограничивает вас цветами вашей
логической палитры.  Чтобы избежать этого ограничения,  вы можете
задать цвет палитры косвенно,  используя относительное значение
палитры TColorRef. Относительное значение TColorRef почти совпадает
с абсолютным значением RGB TColorRef,  но байт  старшего  разряда
установлен  в  2.  Три младших байта содержат значение цвета RGB.
Например,  $020000FF задают значение чистого красного цвета. Если
устройство  поддерживает  системную палитру,  то Windows подберет
максимально соответствующий цвет  RGB  логической  палитры.  Если
устройство  не  поддерживает системную палитру,  то TColorRed
используется так, как если бы он задавал явное значение RGB.

<P><A NAME="l29">
<CENTER><H3>Запрос палитры</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspWindows определяет  функцию,  которая позволяет вам получать
информацию относительно палитры.  GetPaletteEntries  воспринимает
индекс,  диапазон  и указатель на TPaletteEntry и заполняет буфер
заданными элементами палитры.

<P><A NAME="l30">
<CENTER><H3>Модификация палитры</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspЕсть два  способа  изменения  элементов  логической палитры.
Функция SetPaletteEntries берет те  же  самые  аргументы,  что  и
GetPaletteEntries  и  меняет заданные элементы на те,  на которые
указывает третий аргумент.  Обратите внимание на то, что
произведенные  изменения  не  отражаются  в  системной палитре до вызова
RealizePalette, и их не  видно до  перерисовки  области  клиента.
Функция AnimatePalette   воспринимает  те  же  аргументы,  что  и
SetPaletteEntries,  но используется для быстрых изменений палитры
приложения,  и  они  немедленно  становятся видимыми.  При вызове
AnimatePalette элементы палитры с полем peFlags  установленным  в
константу  pc_Reserved  будут  заменены  на соответствующие новые
элементы, и это найдет немедленное отражение в системной палитре.
На другие элементы это никак не повлияет.

<P>&nbsp&nbsp&nbsp&nbspНапример, вам  нужно  взять первые десять элементов палитры,
сменить их значение, добавив на единицу содержание красного цвета
и уменьшив содержимое синего и зеленого. Все эти изменения должны
сразу же стать видимыми (Предполагается, что некоторые из
элементов имеют установленное значение pc_Reserved):

<P><PRE>
     GetObject(ThePalette, SizeOf(NumEntries), @NumEntries);
     if NumEntries >= 10 then
     begin
        GetPaletteEntries(ThePalette, 0, 10, @PaletteEntries);
        for i:=0 to 9 do
      begin
         PaletteEntries[i].peRed:=PaletteEntries[i].peRed+40;
         PaletteEntries[i].peGreen:=PaletteEntries[i].peGreen-40;
         PaletteEntries[i].peBlue:=PaletteEntries[i].peBlue-40;
      end;
        AnimatePalette(ThePalette, 0, 10, @PaletteEntries);
     end;
</PRE>

<P>&nbsp&nbsp&nbsp&nbspВместо AnimatePalette мы могли бы использовать:

<P><PRE>
     SetPaletteEntries(ThePalette, 0, 10, @PaletteEntries);
     RealizePalette(ThePalette);
</PRE>
<P>и затем перерисовать окно, чтобы увидеть изменения цветов.

<P><A NAME="l31">
<CENTER><H3>Реакция на изменения палитры</H3></CENTER><HR><P>

<P>&nbsp&nbsp&nbsp&nbspКогда окно принимает сообщение wm_PaletteChanged, это
свидетельствует о том, что активное окно сменило системную палитру
путем реализации ее логической  палитры.  Окно,  принявшее
сообщение, может отреагировать на него тремя способами: оно может
ничего не делать (очень быстрый способ,  но может привести  к
некорректным цветам),  оно может реализовать свою логическую палитру и
перерисовать себя (медленнее, но цвета будут максимально
корректными), либо оно может реализовать свою логическую палитру и затем
использовать функцию UpdateColors для быстрого изменения  области
клиента в соответствии с системной палитрой. UpdateColors в общем
случае работает быстрее,  чем перерисовка области клиента, но при
ее  использовании могут быть некоторая потеря точности в
цветопередаче.  Поле WParam  записи  TMessage,  переданной  в  сообщении
wm_PaletteChanged,  содержит описатель окна,  которое реализовало
свою палитру. Если в ответ вы решили реализовать свою собственную
палитру,  сначала убедитесь в том, что этот описатель не является
описателем вашего окна, чтобы не создать бесконечного цикла.

<P>&nbsp&nbsp&nbsp&nbspПрограмма PaTest создает и реализует логическую  палитру  из
восьми  цветов.  При нажатии левой кнопки  "мыши" она будет
рисовать раскрашенные квадраты с образцами каждого из цветов
логической  палитры.  При  нажатии правой кнопки происходит сдвиг цветов
логической палитры. Используется индекс палитры TColorRef,
поэтому, когда логическая палитра меняется раскрашенные квадраты также
сменят свой цвет. При использовании индекса палитры TColorRef
может оказаться удобным использование функции PaletteIndex.

<P>&nbsp&nbsp&nbsp&nbspПолный текст программы содержится в файле PALTEST.PAS на
ваших дистрибутивных дискетах.
</HTML></BODY>

